\documentclass[final]{cmpreport}

\usepackage{enumitem}
\usepackage{wasysym}
\usepackage{framed}
\usepackage{pgfgantt,rotating}
\usepackage{subfloat}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{colortbl}

\title{An Evaluation of HTML5\\as a Mobile Gaming Platform}

\author{Joshua Barnett}

\registration{5939968}
\supervisor{Professor Andy Day}

\ccode{CMPC3P2Y}

\summary{
This is my abstract.
}

\acknowledgements{
These are my achknowledgements.
}

\begin{document}

\section{Introduction}
For the past five years it has been evident that mobile devices have risen as one of the foremost dominant ways in which the modern world consumes media and entertainment. Alongside this, a new web standard has been developing. \textit{HTML5} (a popularly abused buzzword) is a new language specification with the primary purpose of succeeding where its predecessors failed, in delivering rich interactive content. Generally \textit{``HTML5''} is used as an all encompassing term that includes a host of technologies, as it alone could not deliver such user experiences. Technologies such as \textit{JavaScript} (JS), \textit{Cascasing Style Sheets} (CSS), \textit{Scalable Vector Graphics} (SVG) and \textit{WebGL}. When used together in varying combinations and configurations these form a Web Platform\footnote{\url{http://docs.webplatform.org/wiki/Main_Page}} on which to convey content and information in new and interesting ways. However, it is currently the convention to refer to this new platform as \textit{HTML5}.

\textit{``Linux''} has similarly been distorted as an all encompassing term for Linux based operating systems such as \textit{Debian}, \textit{Fedora}, and \textit{Ubuntu}. However, \textit{``Linux''} alone is just the open-source kernel which lies at the heart of these distributions but on its own would not be of much use.

\textit{Original equipment manufacturers} (OEMs) such as \textit{Apple}, \textit{LG}, \textit{Nokia} and \textit{Samsung} are becoming progressively competitive in producing better mobile devices for the global market. They offer higher resolution displays, more memory capacity, and increasingly faster processors. This escalation in performance has been a key instigator in the growing support and optimization of \textit{HTML5} and \textit{JavaScript} on mobiles. However, it has only just begun to reach the requirements needed for delivering interactive real-time graphics applications through \textit{HTML5's} features, such as video games.

The purpose of this project is to evaluate the current state of the \textit{HTML5} and its companion technologies on the mobile platform, and to assess whether they provide a suitable means to develop and deploy games. To assist my research I will be designing and creating my own game, expanding my personal understanding of the platform along the way.

\section{HTML5}
\textit{HTML5} is the fifth iteration of the hypertext mark up language. During its previous iterations such as \textit{HTML4.01} there was minimal support for multimedia content. This resulted in a void that was promptly filled by third-party plugins such as \textit{Adobe Flash} and \textit{Microsoft Silverlight}. Such plugins allowed for easy presentation of media such as video, audio and even allowed for interactivity that was used to great effect in games.

Unfortunately many of these plugins are proprietary and closed-source which prevents developers from fixing and debugging inherent issues in the technology. Instead they are dependant on the technology owner for solutions to these problems while being limited to reporting them or finding ``temporary'' workarounds. Often such plugins also require some form of installation process as they are ``add-ons'' and exist outside of the \textit{W3C} standard. 

\citet{Jobs} famously professed his concerns about Flash and presented sound reasoning as to why \textit{Apple} had no intentions of supporting or integrating Flash into their \textit{iOS} devices. Flash was also briefly available for Android but it was short lived and eventually discontinued by \textit{Adobe}. Adobe is continuing to making strides into the mobile platform with their new runtime AIR\footnote{\url{https://www.adobe.com/aboutadobe/pressroom/pressreleases/201002/021510FlashPlayerMWC.html}}. \textit{HTML5} is still currently a work in progress but the \citet{W3C} have made plans to stabilize the specification and help it reach \textit{Recommendation}\footnote{\url{http://www.w3.org/2005/10/Process-20051014/tr.html\#rec-publication}} status as of this year.

\subsection{The Document Object Model (DOM)}
The \textit{document object model} (DOM) is the core of what drives modern web applications. It provides a means to manipulate the structure and style of the original document loaded from a web server at run-time on the client side.

However, what makes \textit{HTML} different from most compiled languages such as \textit{C++} and \textit{Java}, is its a interpreted language. Compiled languages are typically converted into a binary format that compresses their instructions into machine-code allowing for quicker execution. Interpreted languages in contrast are often read line-by-line with their instructions parsed and executed at run-time.

When HTML is interpreted by a web browsers it is parsed into a DOM. The DOM is essentially a representation in memory of what was originally marked down in the static HTML document. This allows the browsers to interpret relations between elements and use them to render the document appropriately. While in memory the information is not longer static allowing for manipulation by other technologies such as JavaScript.

One example of where this manipulation is used to great effect is the \textit{single-page application} (SPA). \textit{SPAs} have significant advantages over that of traditional websites as they can provide a seamless user experience similar to that of desktop applications. Instead of navigating through links that loading separate \textit{HTML} pages they use states to manage the flow, loading information dynamically when required or requested. This methodology shrinks factors such as load times, enables rich interactions, responsiveness while encouraging reuse. \citep{Takada}

\subsection{Web Browsers}
Web browsers are client side applications that render the information requested by the user delivered from a web server. Many of the popular browser vendors such as \textit{Google (Chrome)}, \textit{Apple (Safari)}, and \textit{Mozilla (Firefox)} all have a mobile counterpart. However these mobile counterparts often support a subset of their desktop editions making much of the fringe \textit{HTML5} features even less supported.

\subsection{Cross Compatibility}
Getting a single web application to render and function consistently across a range of browsers can be a huge undertaking. This task has grown exponentially with the introduction of mobile devices because of the endless combinations of hardware, operating systems, and mobile browser applications. Each combination of these variables has the potential to produce unique bugs and quirks specific to a particular test case. As the specification of \textit{HTML5} was being developed much of the new features have been implemented in browsers at the discretion of the browser vendor. This has quickly led to cross compatibility issues as older browsers will support less of these new features and not necessarily be consistent with the other browsers that were available at the time.

Depending on the project specification a developer can rapidly become limited by what features of \textit{HTML} they can utilise. For instance one such feature I had planned on using when initially developing my mobile game was \textit{viewport units}. This feature allows for the scaling of elements based upon the current viewport's dimensions which is especially useful on mobile devices for scaling visual elements relative to the screen's aspect ratio. However the stock web browsers on mobile devices have only recently added support for this feature with it being introduced in version 4.4 of \textit{Android} and 6.0 of \textit{iOS}.

\begin{figure}[h]{A compatibility table for viewport units \label{viewport}}
  \includegraphics[width=1.0\textwidth]{viewport-units.png}
\end{figure}

In cases like this a developer can either limit their target platform range and make use of the fringe features available on mobile devices or use a polyfill also known as a shim. A polyfill is often referred to as code that substitutes the lack of a future \textit{API} by utilising existing features to mimic that of newer fully fledged implementations. \cite{Lawson} I my case I had to polyfill the lack of \textit{viewport units} in older mobile browsers. After searching for a solution I came across the slides of \cite{Kadrmas} presentation that detailed the use of \textit{em} units in \textit{HTML5} games. \textit{em} units were originally intended for scaling document elements relative to the current font size. I used this to implement consistent scaling of my game across differing screen sizes by adjusting the root document element's font size relative to the screen width of the current device. This approach also made it easy to retain a specified aspect ratio, preventing any oddities when displaying on landscape displays.

However, even when polyfilling potential feature gaps in browsers, issues can still occur under a variety of circumstances. One of the most reliable ways in which to ensure compatibility is to actually possess all the mobile devices you plan to support. This solution most of the time is impractical, especially if the developers fund are limit such as in my case. The next best alternative is to either emulator such devices or use online tools such as BrowserStack\footnote{\url{http://www.browserstack.com/}}. Figure \ref{browserstack} shows thumbnails of \textit{MindFlip} on \textit{Android} and \textit{iOS} browsers this is a helpful utility that assists in highlighting obvious incompatibility issues at a glance. The blank thumbnails quickly point out where my game is not loading, which allows me to select and prioritize what devices need debugging. However, with my limited workforce, budget, and time I could really only afford to debug devices I own such as the \textit{Samsung Galaxy S4} and the \textit{Google Nexus 7 (2012)}.

\begin{figure}[h]{Screenshots of MindFlip on various mobile device browsers \label{browserstack}}
  \centering
    \includegraphics[width=0.8\textwidth]{browserstack.png}
\end{figure}

\section{Graphics}
When it comes to rendering in HTML5 are I many different options with varying advantages and disadvantages.

\subsection{Cascading Style Sheets (CSS)}
The fundamentals of web development are that the content of a website is typically marked down in a \texttt{.html} document and the style of this content is embedded alongside or defined within a \texttt{.css}. The browser parses the rules found in the stylesheet identifying referenced document elements in the process. This information then instructs the browser how to render the selected document elements often improving their otherwise bland presentation. Although \textit{HTML} has been getting a much needed update, this begs the question of what its companion \textit{CSS} has been doing in order to enhance the web experience. 

The latest iteration of \textit{CSS} often referred to as \textit{CSS3} provides new and interesting ways in which to style these elements. Notable features include rounded corners, shadows, gradients , transitions or animations , as well as new layouts like multi-columns , flexible box or grid layouts\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS3}}.

The support for these on mobile browsers has been around for quite awhile with much of the older versions supporting them through the use of vendor prefixes. These are a side effect of specification \textit{CSS3} still being a draft as such features were classified as experimental at the time. However, these are starting to be phased out as browser vendors start to agree on specifics and it also provides a means in which to use them providing legacy support for older browsers.

\subsection{Canvas}
\textit{Canvas} is probably the most significant feature that was introduced in \textit{HTML5}, especially for game developers. It finally enables developers to do interactive and dynamic graphics natively in the browser, without third-party plugins.

Effectively \textit{Canvas} is a new \textit{HTML} element that can be used to draw graphics via a \textit{JavaScript API}. Although this may seem a simply concept it has huge application opportunities. However, because the draw calls are being made by \textit{JavaScript} they are also limited to the speed of the \textit{JavaScript} virtual machine. Although there has been much development striving to improve the optimization and speed of \textit{JavaScript} virtual machines such as \textit{Google's V8 JavaScript Engine\footnote{\url{https://code.google.com/p/v8/}}}, it only gets slower when it comes to mobile devices.

% CHANGE THIS WHAT SLOWS IT DOWN IS SOFTWARE RENDERING NO JS VM.

The performance of mobile devices has been on the increase in recent years with an emphasis on \textit{GPUs} \cite{Lin}. The application of these faster processors in mobile browsers has only just started to become common place. There are many ongoing software projects with a focus on accelerating the \textit{HTML5} canvas using the mobile device's \textit{GPU}. Unfortunately there has been a lack of cross platform open-source projects that tackle this issue. \textit{Ejecta} is an is one such project but it current only supports \textit{iOS}. The hybrid mobile application framework \textit{Apache Cordova\footnote{https://cordova.apache.org/}} also provides this feature through a plugin called \textit{FastCanvas\footnote{\url{http://plugreg.com/plugin/phonegap/phonegap-plugin-fast-canvas}}}.

\subsection{WebGL}
\textit{WebGL} is a distillation of the popular \textit{OpenGL} making \textit{GPU} accelerated rendering in the browser now a reality. \textit{WebGL}, a \textit{JavaScript API} is based on the \textit{OpenGL ES (Embedded Systems)} subset, and as the name implies it was designed and optimized for embedded systems such as mobile devices. One streamlined modification \textit{OpenGL ES} made was the removal of the fixed-function \textit{API} introduced in \textit{OpenGL 1.0} enabling the use and compilation of modern shaders.

\textit{WebGL} has been in development for the past three years which came to maturity as of early last year when the first a stable version was released. As this is a new technology it has only just begun surfacing in the wild, one notable example is the \textit{PlayStation 4's} user interface. In a revealing presentation given by \cite{Olmstead} it was declared that the move to \textit{WebGL} was done to ensure cross platform support. This potentially hints at Sony's future plans to bring their games to multiple platforms including mobile devices through their \textit{PlayStation Now} streaming service.

However, the support for \textit{WebGL} through mobile browsers is essentially nonexistent to date. One company striving to change that is \textit{Ludei}, who are in the early stages of rolling out their new technology \textit{CocoonJS}. \textit{CocoonJS} is a means of packaging and publishing \textit{HTML5} applications on mobile devices. In amongst this framework is the facilitation of \textit{WebGL} letting it tap into the onboard \textit{GPU} available on most modern mobile devices. Many of the demos they provide demonstrate close to near native performance. This makes \textit{WebGL} a feasible avenue for game development on mobile devices, with the added bonus of being cross platform ready.

\section{Audio}
a

\subsection{\texttt{<audio>} Element}
a

\subsection{Web Audio API}
a

\subsection{Native Audio}
a

\section{Game Design}
a

\subsection{Player Interaction}
a

\subsection{Gameplay \& Mechanics}
a

\subsection{Feedback}
Throughout the development and prototyping of MindFlip it was important to take into consideration the reactions and feedback of players. So whenever the chance arose I would hand over my phone containing my latest stable build of the game and observe others playing it from a third-party perspective.

Preconceptions can be a double edged sword when used in game design. Often they can be used to draw parallels between activities in contemporary games such as my own. This acts as a shortcut when teaching a player new or similar gameplay mechanics. However, these can also be stumbled upon accidently from a developer's perspective as their own preconceptions about games will likely be vast by comparison to the average player.

This was the case with the initial draft of introductory level. In the beginning the first two card symbols the player encountered were a red nought and a blue cross on a three-by-three grid. After showing the game to my sister while providing no tutorial, the first actions she made were to produce a winning \emph{Tic-tac-toe} game state. This made it apparent that there was a flaw in my game design, because the symbols are common to a pre-existing game namely \emph{Tic-tac-toe} the player receives mixed signals about how to play the game from the offset leading to frustration and confusion. I later decided to go for simpler more abstract symbols such as circles, squares, and triangles in my initial set of levels do to their generic associations they imply simplicity leaving the player open to learn the game mechanics.

\section{Development Stack}
When creating a game targeting HTML5 it can be difficult to know what workflow to invest in. Developers each have their own preferences and beliefs as to what is the best way to work with their priorities often being similar but achieved in different ways.

\subsection{Preprocessors \& Alternatives}
\textit{JavaScript} in its current state (\textit{ECMAScript 5.1}) is an underwhelming language, especially when compared to more mature languages such as \textit{C++} or \textit{Java}. It lacks native support for object-orientated features such as inheritance, generics, and abstraction. Originally \textit{JavaScript} was never intended for use in large-scale development projects however, due to its inherent portability it has become widespread. Until its apparent deficiencies are rectified and standardised in its next iteration (\textit{ECMAScript 6}), developers have to over utilise its strengths, such as being loosely typed. To help aleve \textit{JavaScript's} growing pains many organisations have been developing alternatives and middle ware to deal with its short comings.

Heavily standardised languages such as \textit{JavaScript} often have very long iteration cycles, making it difficult for them to adapt swiftly however, this does help to ensure and maintain a language's stability in the long term. By comparison \textit{transpilers} (source-to-source compilers) can transform a better suited custom language into plain \textit{JavaScript}, by shimming the missing functionality at compile time. They also make it easier for developers to transition to web development without having to learn the semantics of \textit{JavaScript}. In figure \ref{ranking} are the top thirty-nine most popular programming languages as of January 2014. These statistics were calculated based upon their frequency of occurrence on GitHub (x-axis) and Stack Overflow (y-axis); popular community websites with a focus on programming. By comparing it to one from last year\footnote{http://redmonk.com/sogrady/2013/07/25/language-rankings-6-13/} it is clear to see their has been a rise in popularity. Some such preprocessors include CoffeeScript\footnote{http://coffeescript.org/}, Clojure\footnote{http://clojure.org/}, Dart\footnote{https://www.dartlang.org/} and TypeScript\footnote{http://www.typescriptlang.org/}. The full graph\footnote{http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/} is cumbersome so this snippet is only of the top quadrant.

\begin{figure}[h]{The RedMonk Programming Language Rankings: January 2014 \label{ranking}}
  \includegraphics[width=1.0\textwidth]{lang-rank-114-wm.png}
\end{figure}

The advantages of transpilers often mean that less can be written in order to achieve the same functionality in its targeted language. Simple common activities such as array iteration, class extension, and appending vendor prefixes can become unnecessarily ceremonious especially in the case of \textit{JavaScript} when shimming non-existent functionality. These transpilers can offer an alternative means in which to achieve the same results with less code and effort required on the part of the developer.
\subsubsection{Dart}
\textit{Google's Dart} ``is a new platform for scalable web app engineering'' which comes in the form of several tools. First there is \textit{Dart} the language which is an alternative to writing plain \textit{JavaScript} with a host of additional built-in and libraries language features akin to \textit{Java} \cite{Fortuna}. Second there is \textit{DartVM} a virtual machine that comes as a standalone program and also happens to be embedded in the \textit{Google Chrome} browser. The \textit{DartVM} works similarly to a typical \textit{JavaScript} virtual machine with the difference being it interprets \texttt{.dart} code instead of \textit{.js} with significant performance advantages \cite{Schneider}. Lastly there is the \textit{dart2js} compiler, which is effectively a backwards compatibility tool to ensure any application created on the \textit{Dart} platform will still work through conventional means.

\subsubsection{TypeScript}
\textit{Microsoft's TypeScript} by its own admission ``is a typed superset of JavaScript that compiles to plain JavaScript.'' which makes it very flexible alternative. This effectively means that you can continue to write plain \textit{JavaScript} and no restrictions will be imposed by the \textit{TypeScript} transpiler. This helps greatly if a developer already has a large \textit{JavaScript} codebase which they wants to utilise during the development of a large scale application. \textit{TypeScript} offers some of the inherently missing language features of \textit{JavaScript} such as type annotations, classes, interfaces and modules. There are also plans to support \textit{ECMAScript 6} features once it becomes the standard. Another positive remark about the output produced by the \textit{TypeScript} transpiler is it produces rather legible \textit{JavaScript} making it easy to see the relationships between the source and target languages.

Because the compile target of these transpilers is \textit{JavaScript} it is possible to take advantage of them when developing mobile web applications such as video games. When I first started developing my game I chose to use \textit{TypeScript} because it was syntaxitcally similar to that of \textit{ActionScript 3}, where my background lies. However, due to the immaturity of the project at the time and a lack of core \textit{JavaScript} knowledge on my part, I felt it was best not to continue using it as I did not have the time to invest in fully learning its ins and outs. I also felt working at this level of abstraction could potentially lead to delays when debugging later in development. However, as of the 2nd of April 2014 close to the time of writing the specification for \textit{TypeScript 1.0} has been finalised and its current status is \textit{stable}. Going forward after this project I am eager to re-evaluate it now that it has had time to mature.

\subsection{JavaScript Modules}
\textit{JavaScript} is typically created as separate \texttt{.js} text files that are then referenced in a \texttt{.html} document by \texttt{<script>} tags. When the web browser finds scripts linked by these tags it will request them from the web server and inject them into the document once loaded. This presents a few problems for large and complex web applications which will often require many scripts each having to be requested and loaded synchronously. Every one of these request has an overhead, which is compounded when a vast quantity are being made. This can lead to suboptimal load times.

To combat this problem a developer could attempt to write all their code in one \texttt{.js} file. This file can quickly become colossal making it difficult to manage and refactor, especially on large scale projects. Alternatively the developer can split their code into several \texttt{.js} files that will all have to be referenced by a corresponding \texttt{<script>} tag. Therefore the more organised the codebase becomes the more requests the browser has to make. The developer also has to micromanage these \texttt{<script>} tags to ensure their ordering is correct. The ordering is important because one script could be referencing another that has not yet been loaded, thus causing runtime errors. This approach also presents issues when attempting to introduce software engineering best practices such as unit testing because the interdependencies between these scripts are not clearly defined.

One solution to this common problem is the \textit{module} design pattern. \textit{JavaScript} has an official name \textit{ECMAScript}, and version \textit{5.1} (ECMA-262\footnote{\url{http://www.ecma-international.org/ecma-262/5.1/}}) is the current standard. However, this present language specification does not support \textit{modules}. The 6th version\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html}} of the \textit{ECMAScript} specification is currently being drafted with plans to include modules but until then developers must seek other alternatives.

There are a variety of libraries that offer solutions such as \textit{RequireJS\footnote{\url{http://requirejs.org/}}}, \textit{HeadJS\footnote{\url{http://headjs.com/}}} and \textit{yepnope.js\footnote{\url{http://yepnopejs.com/}}}. However, personally I found \textit{Browserify\footnote{\url{http://browserify.org/}}} to be the simplest and the most supported amongst the \textit{Node.js} community. \textit{Browserify} enables developers to write their \textit{JavaScript} code in numerous files and when one file requires another it can be injected via the \texttt{require(`example');} function. Once a developer has written all their code they can recursively bundle all their modules starting with a root module similar to that of a main class in conventional programming languages. This provides the developer with the best of both scenarios as all their code will be built into a single \texttt{.js} file (including their external libraries), while allowing for easy management and refactoring of their core codebase through individual source files.

Most might think that this will in turn cause complications when debugging. As when the code breaks it will do so in the colossal \texttt{.js} file that the browser is running. This is where source maps come in. Source maps provide linkage between the original \texttt{.js} source files and their bundled counterparts making breakpoints and stepping through code painless. \cite{Seddon}

This process can also be made seamless by \textit{Watchify} which automatically recompiles the \textit{Browserify} bundle whenever a module file has been updated. This allows for the developer to work on their original source files and as soon as the file has been saved it have rebuilt the bundle ready to reloaded in the browser for testing.

After the modules have been bundled a further step called minification which involves taking legible \textit{JavaScript} and compressing it down into its most minimal form by removing unnecessary characters such as a whitespace and shrinking instance names. This process can further decrease the \texttt{.js} file size making load times marginally faster while also partially obfuscating the original code from prying eyes.

\cite{Hanselman} proclaimed that \textit{JavaScript} has become akin to a assembly language for the web. Which is the impression a lot of people will get when taking a peek at the source of popular website such as \textit{Google} or \textit{Facebook}. This is some what understandable given the that \textit{JavaScript} is as low-level as developers can get when programming for the web. However, a happy side effect of being closely tide with the web is it has become now one of the most portable languages to date, because every web enabled device has a browser, and every browser has a \textit{JavaScript} virtual machine. This makes \textit{JavaScript} a very cross-platform language to develop games with and reaching a wide audience is key when maximising chances for success.

\subsection{Model View Controller (MVC)}
a

\subsection{Templates}
a

\subsection{Build Pipeline}
a

\section{Mobile Deployment}
One of the challenges that faces mobile developers is how to package their applications for the mobile platform, which spans such a wide variety of hardware and operating systems (iOS\footnote{\url{http://www.apple.com/ios/}}, Android\footnote{\url{http://www.android.com/}}, Windows Phone\footnote{\url{http://www.windowsphone.com/}}, Ubuntu\footnote{\url{http://www.ubuntu.com/phone}}), \cite{Feijoo}. This poses a problem especially for the smaller companies as to develop native variants of an application for each platform while retaining a common vision is demanding on both financial and chronological frontiers. Larger companies that facilitate and accommodate such resources, do however frequently benefit from having a superior overall user experience. Most native applications built with their corresponding software development kits have direct access to device specific  application programming intefaces (APIs). This often results in native applications having faster performance and better system user interface integration. Native applications compile to binary machine code that is then interpreted via its relative hardware architecture making it vastly faster than JavaScript which is interpreted at run-time via a browser or web-view. This is most apparent when it comes to developing 3D gaming experiences as these can often be most the most performance taxing, \cite{Kulloli}.

When comparing HTML5 based mobile applications to native there was another significant disadvantage as there was no way to access device APIs. Such APIs are required to make use of the most 

 hardware features on mobile devices such as the camera, device orientation and battery status. Especially considering that each API varies dependant on operating system and then again on hardware specification. For instance not all mobiles have front facing cameras or high-dpi (dots per inch) screens but a vast majority do. So it becomes quite a challenge when trying to build an application that adapts from phone-to-phone without excluding a particular sector of an audience from the core user experience, \cite{Charland}.

A project with the sole purpose of remedying such issues is that of PhoneGap a mobile development framework originally created by a company called Nitboi. After PhoneGap began to make strides the company was purchased and enveloped by Adobe in 2011, \cite{Adobe}. Then after the project matured under Adobe's supervision the project was donated to the Apache Software Foundation. This was to ensure that the project was properly maintained when made open source under the Apache License Version 2.0\footnote{\url{http://www.apache.org/licenses/LICENSE-2.0.html}}. A formality due to this hand over was that the open source variety of the project had to operate under a different name to avoid trademark ambiguity, \cite{Leroux}. Adobe's PhoneGap still functions as a separate entity as a distribution of Apache Cordova offering services such as cloud compilation\footnote{\url{https://build.phonegap.com/}}.

Apache Cordova\footnote{\url{http://cordova.apache.org/}} is a platform for building native mobile applications using HTML, CSS and JavaScript. It achieves this by providing developers with a set of relative device APIs that allow for access of functions previous obfuscated from web technologies by the native system. It also assists with handling a lot of the cross-platform concerns previously mention when targeting multiple platforms and device hardware.

\subsection{Packaging}
a

\subsection{Debugging}
a

\subsection{Profiling}
a


\clearpage
\bibliography{5939968}

\end{document}

